<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Slicer - V23.1 Matrix Defense</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            background-color: #111; 
            font-family: 'Press Start 2P', cursive; 
            color: white;
            user-select: none;
            transition: background 1s ease; 
        }

        canvas { display: block; }
        
        /* LAYOUT */
        #game-ui, #main-menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
            justify-content: space-between; padding: 20px; box-sizing: border-box;
            z-index: 10;
        }

        /* MAIN MENU */
        #main-menu {
            background: rgba(15, 15, 20, 0.95);
            pointer-events: auto;
            justify-content: center;
            align-items: center;
            z-index: 50;
            backdrop-filter: blur(10px);
            transition: opacity 0.5s;
        }

        .menu-title {
            font-size: 4rem; color: #00d2d3; 
            text-shadow: 4px 4px 0px #000, 0 0 20px rgba(0, 210, 211, 0.5);
            margin-bottom: 10px; text-transform: uppercase; text-align: center;
            line-height: 1.2;
        }
        .menu-subtitle {
            color: #b2bec3; font-size: 0.8rem; margin-bottom: 50px; letter-spacing: 2px;
            text-align: center;
        }

        .level-grid { 
            display: flex; flex-wrap: wrap; gap: 15px; 
            max-width: 800px; justify-content: center; 
        }

        .level-card {
            background: #2d3436; border: 4px solid #636e72; 
            width: 90px; height: 90px;
            cursor: pointer; display: flex; flex-direction: column; 
            justify-content: center; align-items: center;
            transition: all 0.1s; position: relative;
        }
        .level-card:hover { 
            border-color: #fff; transform: translateY(-4px); 
            box-shadow: 0 6px 0 rgba(0,0,0,0.5);
        }
        .level-card:active { transform: translateY(0px); box-shadow: none; }
        
        .level-card.locked { 
            opacity: 0.6; cursor: not-allowed; 
            background: #1e272e; border-color: #2d3436; 
        }
        .level-card.locked:hover { transform: none; box-shadow: none; border-color: #2d3436; }
        
        .lvl-num { font-size: 2rem; color: #fff; }
        .lock-icon { font-size: 1.5rem; display: none; color: #636e72; }
        .locked .lock-icon { display: block; }
        .locked .lvl-num { display: none; }

        /* IN-GAME HUD */
        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; width: 100%; }
        
        .pixel-btn {
            pointer-events: auto; background: #0984e3; border: 3px solid #74b9ff;
            color: white; padding: 12px 16px; cursor: pointer; font-family: inherit; font-size: 0.7rem;
            box-shadow: 4px 4px 0px rgba(0,0,0,0.5); margin-left: 10px;
            text-transform: uppercase;
        }
        .pixel-btn:hover { transform: translate(-2px, -2px); box-shadow: 6px 6px 0px rgba(0,0,0,0.5); filter: brightness(1.1); }
        .pixel-btn:active { transform: translate(2px, 2px); box-shadow: 0px 0px 0px #000; }

        #menu-btn { background: #d63031; border-color: #ff7675; }
        #restart-btn { background: #6c5ce7; border-color: #a29bfe; }
        #ui-toggle { width: 40px; text-align: center; padding: 12px 0; }

        /* STATUS & OVERLAYS */
        #cut-status {
            position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%);
            color: #ff7675; text-shadow: 2px 2px 0 #000; display: none; font-size: 0.8rem;
            background: rgba(0,0,0,0.8); padding: 5px 10px; border: 1px solid #ff7675;
        }

        /* MESSAGES */
        #msg-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            pointer-events: none; background: rgba(0,0,0,0.8);
            opacity: 0; transition: opacity 0.3s;
        }
        #msg-container.visible { opacity: 1; pointer-events: auto; }
        
        .big-msg { font-size: 3rem; text-shadow: 4px 4px 0 #000; margin-bottom: 30px; }
        .win { color: #55efc4; }
        .lose { color: #ff7675; }

        .controls-hint {
            position: absolute; bottom: 20px; right: 20px;
            text-align: right; font-size: 0.6rem; color: rgba(255,255,255,0.5);
            text-shadow: 1px 1px 0 #000;
        }

        #level-info {
            position: absolute; bottom: 20px; left: 20px; text-align: left; pointer-events: none;
        }
        
        /* FADE TRANSITION */
        #screen-fade {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: #000; z-index: 200; pointer-events: none;
            opacity: 0; transition: opacity 0.5s;
        }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
</head>
<body>

    <div id="screen-fade"></div>
    <div id="flash-overlay" style="position:absolute;width:100%;height:100%;background:white;opacity:0;pointer-events:none;z-index:99;"></div>

    <!-- MAIN MENU -->
    <div id="main-menu">
        <div>
            <div class="menu-title">SPACE<br>SLICER</div>
            <div class="menu-subtitle">V23.1 - MATRIX DEFENSE</div>
        </div>
        <div class="level-grid" id="level-list"></div>
    </div>

    <!-- GAME UI -->
    <div id="game-ui" style="display:none;">
        <div class="hud-top">
            <div style="font-size:0.8rem; color:#00d2d3; text-shadow: 2px 2px 0 #000;">
                LEVEL <span id="ui-lvl-num">1</span>
            </div>
            <div style="pointer-events: auto; display:flex;">
                <!-- Oracle Removed -->
                <button id="restart-btn" class="pixel-btn">RETRY</button>
                <button id="menu-btn" class="pixel-btn">EXIT</button>
                <button id="ui-toggle" class="pixel-btn" title="Hide UI">H</button>
            </div>
        </div>

        <div id="cut-status">METAL BLOCKS CUT</div>

        <div id="msg-container">
            <div id="win-msg" class="big-msg win">CLEARED!</div>
            <div id="death-msg" class="big-msg lose">WIPED OUT</div>
            
            <div id="level-complete-ui" style="display:flex; gap:20px;">
                <button class="pixel-btn" onclick="returnToMenu()">MENU</button>
                <button class="pixel-btn" style="background:#00b894; border-color:#55efc4;" id="next-lvl-btn" onclick="loadNextLevel()">NEXT LEVEL</button>
            </div>
            <div id="retry-ui" style="display:none;">
                <button class="pixel-btn" onclick="reloadCurrentLevel()">TRY AGAIN (R)</button>
            </div>
            <div id="retry-hint" style="display:none; font-size:0.7rem; margin-top:10px; color:#aaa;">PRESS 'R' TO RETRY</div>
        </div>
        
        <div id="level-info">
            <div id="level-title" style="color:#a29bfe; margin-bottom:8px; text-shadow: 2px 2px 0 #000;"></div>
            <div id="level-desc" style="font-size:0.6rem; color:#dfe6e9; text-shadow: 1px 1px 0 #000;"></div>
        </div>

        <div class="controls-hint">
            <p>WASD / ARROWS : MOVE</p>
            <p>SPACE : JUMP</p>
            <p>MOUSE DRAG : CUT REALITY</p>
        </div>
    </div>

    <canvas id="world"></canvas>

    <script>
        // --- AUDIO ENGINE ---
        const AudioEngine = {
            ctx: null, gain: null, droneSource: null, isInit: false,
            init: function() {
                if (this.isInit) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.gain = this.ctx.createGain();
                this.gain.connect(this.ctx.destination);
                this.gain.gain.value = 0.4; 
                this.startDrone();
                this.isInit = true;
            },
            startDrone: function() {
                const bufferSize = this.ctx.sampleRate * 5; 
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.ctx.createBufferSource(); noise.buffer = buffer; noise.loop = true;
                const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 150;
                const lfo = this.ctx.createOscillator(); lfo.type = 'sine'; lfo.frequency.value = 0.1; 
                const lfoGain = this.ctx.createGain(); lfoGain.gain.value = 50; 
                lfo.connect(lfoGain); lfoGain.connect(filter.frequency);
                const masterGain = this.ctx.createGain(); masterGain.gain.value = 0.15; 
                noise.connect(filter); filter.connect(masterGain); masterGain.connect(this.gain);
                noise.start(); lfo.start(); this.droneSource = noise;
            },
            playJump: function() {
                if(!this.ctx) return; const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator(); const g = this.ctx.createGain();
                osc.type = 'square'; osc.frequency.setValueAtTime(150, t); osc.frequency.linearRampToValueAtTime(300, t+0.1);
                g.gain.setValueAtTime(0.05, t); g.gain.exponentialRampToValueAtTime(0.01, t+0.1);
                osc.connect(g); g.connect(this.gain); osc.start(t); osc.stop(t+0.1);
            },
            playLand: function() {
                if(!this.ctx) return; const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator(); const g = this.ctx.createGain();
                osc.type = 'triangle'; osc.frequency.setValueAtTime(80, t); osc.frequency.exponentialRampToValueAtTime(40, t+0.1);
                g.gain.setValueAtTime(0.05, t); g.gain.exponentialRampToValueAtTime(0.01, t+0.1);
                osc.connect(g); g.connect(this.gain); osc.start(t); osc.stop(t+0.1);
            },
            playCut: function() {
                if(!this.ctx) return; const t = this.ctx.currentTime;
                const bufferSize = this.ctx.sampleRate * 0.2; const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0); for (let i=0; i<bufferSize; i++) data[i] = Math.random()*2-1;
                const noise = this.ctx.createBufferSource(); noise.buffer = buffer; const g = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter(); filter.type = 'bandpass'; filter.frequency.setValueAtTime(800, t); filter.frequency.exponentialRampToValueAtTime(100, t+0.2);
                g.gain.setValueAtTime(0.1, t); g.gain.exponentialRampToValueAtTime(0.01, t+0.2);
                noise.connect(filter); filter.connect(g); g.connect(this.gain); noise.start(t);
            },
            playDie: function() {
                if(!this.ctx) return; const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator(); const g = this.ctx.createGain();
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, t); osc.frequency.exponentialRampToValueAtTime(10, t+0.4);
                g.gain.setValueAtTime(0.1, t); g.gain.linearRampToValueAtTime(0, t+0.4);
                osc.connect(g); g.connect(this.gain); osc.start(t); osc.stop(t+0.4);
            },
            playWin: function() {
                if(!this.ctx) return; const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator(); const g = this.ctx.createGain();
                osc.type = 'sine'; osc.frequency.setValueAtTime(400, t); osc.frequency.setValueAtTime(600, t+0.1); osc.frequency.setValueAtTime(800, t+0.2);
                g.gain.setValueAtTime(0.1, t); g.gain.linearRampToValueAtTime(0, t+0.5);
                osc.connect(g); g.connect(this.gain); osc.start(t); osc.stop(t+0.5);
            }
        };

        // --- SPRITE GENERATOR ---
        const Textures = {};
        function generateTexture(name, color, type) {
            const c = document.createElement('canvas');
            const ctx = c.getContext('2d');
            const size = 64; c.width = size; c.height = size;
            ctx.imageSmoothingEnabled = false;
            if (type === 'player') {
                ctx.fillStyle = color; ctx.fillRect(16, 20, 32, 28);
                ctx.fillStyle = '#ffeaa7'; ctx.fillRect(16, 8, 32, 16); 
                ctx.fillStyle = '#000'; ctx.fillRect(22, 14, 6, 6); ctx.fillRect(38, 14, 6, 6);
                ctx.fillStyle = '#fab1a0'; ctx.fillRect(16, 48, 10, 8); ctx.fillRect(38, 48, 10, 8);
            } else if (type === 'enemy') {
                ctx.fillStyle = color; ctx.beginPath();
                ctx.moveTo(10, 60); ctx.lineTo(32, 10); ctx.lineTo(54, 60); ctx.fill();
                ctx.fillStyle = '#fff'; ctx.fillRect(20, 35, 8, 8); ctx.fillRect(36, 35, 8, 8);
                ctx.fillStyle = '#000'; ctx.fillRect(22, 37, 4, 4); ctx.fillRect(38, 37, 4, 4);
            } else if (type === 'block') {
                ctx.fillStyle = color; ctx.fillRect(0, 0, size, size);
                ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 4;
                ctx.strokeRect(0, 0, size, size);
                ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(size,size); ctx.stroke();
            } else if (type === 'booster') {
                ctx.fillStyle = color; ctx.fillRect(0,0,size,size);
                ctx.fillStyle = '#fff'; ctx.beginPath();
                ctx.moveTo(32, 5); ctx.lineTo(55, 45); ctx.lineTo(9, 45); ctx.fill();
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(2,2,60,60);
            } else if (type === 'box') {
                ctx.fillStyle = color; ctx.fillRect(0, 0, size, size);
                ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 4;
                ctx.strokeRect(0, 0, size, size);
                ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(size,size); ctx.stroke();
            }
            Textures[name] = c.toDataURL();
        }
        generateTexture('player', '#0984e3', 'player'); generateTexture('enemy', '#e17055', 'enemy');
        generateTexture('metal', '#636e72', 'block'); generateTexture('wood', '#e1b12c', 'block');
        generateTexture('booster', '#00d2d3', 'booster'); generateTexture('box', '#fdcb6e', 'block');

        // --- CONFIG ---
        const ENGINE_CONFIG = { positionIterations: 8, velocityIterations: 8 };
        const PLAYER_CONFIG = { width: 40, height: 60, speed: 5.5, jumpForce: 0.6, color: '#00d2d3' };
        const WORLD_COLORS = { ground: '#353b48', metal: '#718093', wood: '#e1b12c', box: '#fbc531', enemy: '#e84118', goal: '#4cd137' };
        const THEMES = { basic: "linear-gradient(to bottom, #2d3436, #111)", sky: "linear-gradient(to bottom, #74b9ff, #0984e3)", cave: "linear-gradient(to bottom, #2d3436, #636e72)", lava: "linear-gradient(to bottom, #e17055, #d63031)" };

        // --- LEVELS ---
        const LEVELS = [
            { id: 0, title: "1. JUMP", theme: "basic", playerStart: { x: 200, y: 600 }, goal: { x: 1500, y: 600 }, blocks: [{ x: 0, y: 800, w: 600, h: 100, type: 'metal' }, { x: 800, y: 800, w: 1000, h: 100, type: 'metal' }], texts: [ { x: 700, y: 600, content: "GAP" } ] },
            { id: 1, title: "2. SLICE", theme: "cave", playerStart: { x: 100, y: 600 }, goal: { x: 3000, y: 600 }, blocks: [{ x: 0, y: 800, w: 500, h: 100, type: 'metal' }, { x: 2500, y: 800, w: 600, h: 100, type: 'metal' }], texts: [ { x: 1500, y: 600, content: "TOO FAR" }, { x: 1500, y: 500, content: "CUT SPACE" } ] },
            { id: 2, title: "3. METAL ISLES", theme: "sky", playerStart: { x: 100, y: 600 }, goal: { x: 3500, y: 600 }, blocks: [{ x: 0, y: 800, w: 400, h: 100, type: 'metal' }, { x: 1200, y: 800, w: 400, h: 100, type: 'metal' }, { x: 2400, y: 800, w: 400, h: 100, type: 'metal' }, { x: 3400, y: 800, w: 400, h: 100, type: 'metal' }], texts: [{ x: 800, y: 600, content: "CUT HERE" }, { x: 2000, y: 600, content: "AND HERE" }] },
            { id: 3, title: "4. SKY ISLES", theme: "sky", playerStart: { x: 200, y: 1000 }, goal: { x: 200, y: 200 }, blocks: [{ x: 0, y: 1200, w: 600, h: 100, type: 'metal' }, { x: 0, y: 300, w: 400, h: 50, type: 'metal' }, { x: 2000, y: 1200, w: 300, h: 100, type: 'metal' }, { x: 2100, y: 1150, w: 100, h: 50, type: 'booster' }], texts: [{ x: 1200, y: 1000, content: "BRING BOOSTER" }, { x: 2000, y: 200, content: "FLY UP" }] },
            { id: 4, title: "5. THE ASCENT", theme: "lava", playerStart: { x: 200, y: 1000 }, goal: { x: 200, y: -600 }, blocks: [{ x: 0, y: 1200, w: 800, h: 100, type: 'metal' }, { x: 2500, y: 1200, w: 200, h: 100, type: 'metal' }, { x: 2550, y: 1150, w: 100, h: 50, type: 'booster' }, { x: 200, y: 400, w: 300, h: 50, type: 'metal' }, { x: 1000, y: 400, w: 200, h: 50, type: 'wood' }, { x: 1800, y: 400, w: 200, h: 50, type: 'wood' }, { x: 3000, y: 400, w: 200, h: 50, type: 'metal' }, { x: 3050, y: 350, w: 100, h: 50, type: 'booster' }, { x: 150, y: -400, w: 200, h: 50, type: 'metal' }], enemies: [ { x: 1100, y: 350 }, { x: 1900, y: 350 } ], texts: [{ x: 1000, y: 1000, content: "GET BOOSTER" }, { x: 600, y: 300, content: "CUT TO CROSS" }] },
            { id: 5, title: "6. LONG BRIDGE", theme: "cave", playerStart: { x: 200, y: 600 }, goal: { x: 3400, y: -200 }, spawners: [{ x: 1000, y: 200, interval: 2500 }, { x: 1800, y: 200, interval: 2000 }, { x: 2600, y: 200, interval: 2200 }], blocks: [{ x: 0, y: 800, w: 400, h: 100, type: 'metal' }, { x: 400, y: 800, w: 3000, h: 50, type: 'wood' }, { x: 400, y: 100, w: 3000, h: 50, type: 'metal' }, { x: 3400, y: 800, w: 400, h: 100, type: 'metal' }, { x: 3800, y: 400, w: 50, h: 500, type: 'wood' }, { x: 5000, y: 800, w: 300, h: 100, type: 'metal' }, { x: 5100, y: 750, w: 100, h: 50, type: 'booster' }, { x: 3400, y: -200, w: 200, h: 50, type: 'metal' }], texts: [ { x: 1000, y: 500, content: "SURVIVE THE RAIN" }, { x: 3600, y: 600, content: "FETCH BOOSTER" } ] },
            
            // --- NEW LEVEL 7: MATRIX DEFENSE ---
            {
                id: 6, title: "7. MATRIX DEFENSE", theme: "lava",
                playerStart: { x: 100, y: 600 }, goal: { x: 4000, y: 600 },
                spawners: [
                    { x: 1200, y: 550, interval: 2000, enemyOpts: { velocity: {x:-6, y:0} } },
                    { x: 3800, y: 600, interval: 1200, enemyOpts: { velocity: {x:-20, y:0} } }
                ],
                blocks: [
                    // Floor
                    { x: 0, y: 800, w: 4500, h: 100, type: 'metal' },
                    // Protection 1
                    { x: 600, y: 600, w: 50, h: 200, type: 'metal' },
                    // Wood Wall (Cuttable)
                    { x: 1500, y: 500, w: 100, h: 300, type: 'wood' },
                    // Goal Platform
                    { x: 4000, y: 500, w: 200, h: 300, type: 'metal' }
                ],
                texts: [
                    { x: 400, y: 400, content: "CUT PROJECTILES!" },
                    { x: 2500, y: 400, content: "CUT SPACE TO DODGE" }
                ]
            },

            { id: 7, title: "8. THREAD NEEDLE", theme: "cave", playerStart: { x: 200, y: 600 }, goal: { x: 4000, y: 600 }, blocks: [{ x: 0, y: 800, w: 800, h: 100, type: 'metal' }, { x: 1000, y: 200, w: 100, h: 1000, type: 'metal' }, { x: 2500, y: 200, w: 100, h: 1000, type: 'metal' }, { x: 3500, y: 800, w: 800, h: 100, type: 'metal' }], texts: [ { x: 1800, y: 600, content: "CUT BETWEEN WALLS" } ] },
            { id: 8, title: "9. BOOSTER RELAY", theme: "sky", playerStart: { x: 200, y: 600 }, goal: { x: 4000, y: -1000 }, blocks: [{ x: 0, y: 800, w: 600, h: 100, type: 'metal' }, { x: 1500, y: 800, w: 200, h: 50, type: 'metal' }, { x: 1550, y: 750, w: 100, h: 50, type: 'booster' }, { x: 3000, y: 0, w: 200, h: 50, type: 'metal' }, { x: 3050, y: -50, w: 100, h: 50, type: 'booster' }, { x: 3800, y: -800, w: 400, h: 50, type: 'metal' }], texts: [ { x: 800, y: 600, content: "CHAIN BOOSTERS" } ] },
            { id: 9, title: "10. THE GAUNTLET", theme: "lava", playerStart: { x: 200, y: 800 }, goal: { x: 4500, y: 800 }, blocks: [{ x: 0, y: 1000, w: 5000, h: 100, type: 'metal' }, { x: 1000, y: 800, w: 50, h: 200, type: 'metal' }, { x: 2000, y: 600, w: 50, h: 400, type: 'wood' }, { x: 3000, y: 800, w: 100, h: 50, type: 'booster' }, { x: 4000, y: 600, w: 50, h: 400, type: 'metal' }], enemies: [ { x: 1500, y: 900 }, { x: 2500, y: 900 }, { x: 3500, y: 900 } ], texts: [ { x: 500, y: 500, content: "SURVIVE" } ] }
        ];

        let unlockedLevels = 1;
        let currentLevelIndex = 0;

        // --- MATTER JS ---
        const { Engine, Render, Runner, World, Bodies, Body, Composite, Events, Vector, Query } = Matter;
        let engine, render, runner, world, player, playerSensor;
        let isGrounded=false, isDragging=false, dragStart={x:0,y:0}, dragCurrent={x:0,y:0}, isCutValid=true;
        let particles=[], tutorialTexts=[], currentLevelData=null;
        let isDead=false, levelComplete=false;
        let trailTimer = 0;

        function init() {
            engine = Engine.create(ENGINE_CONFIG);
            world = engine.world;
            engine.gravity.y = 1.6; 

            render = Render.create({
                canvas: document.getElementById('world'),
                engine: engine,
                options: { width: window.innerWidth, height: window.innerHeight, wireframes: false, background: 'transparent', pixelRatio: 1, hasBounds: true }
            });

            setupMainMenu();
            setupInputs();
            setupCollisionEvents();
            
            document.getElementById('menu-btn').onclick = returnToMenu;
            document.getElementById('restart-btn').onclick = reloadCurrentLevel;
            document.getElementById('ui-toggle').onclick = () => {
                const ui = document.getElementById('game-ui');
                ui.style.opacity = ui.style.opacity === '0' ? '1' : '0';
            };

            window.addEventListener('click', () => {
                AudioEngine.init();
                if (AudioEngine.ctx && AudioEngine.ctx.state === 'suspended') AudioEngine.ctx.resume();
            }, { once: true });

            Events.on(engine, 'beforeUpdate', gameLoop);
            Events.on(render, 'afterRender', renderCustom);
            
            Render.run(render);
            runner = Runner.create();
            Runner.run(runner, engine);
            window.addEventListener('resize', () => { render.canvas.width=window.innerWidth; render.canvas.height=window.innerHeight; });
        }

        function fadeTransition(callback) {
            const fade = document.getElementById('screen-fade');
            fade.style.opacity = 1;
            setTimeout(() => {
                callback();
                setTimeout(() => fade.style.opacity = 0, 100);
            }, 500);
        }

        function setupMainMenu() {
            const list = document.getElementById('level-list');
            list.innerHTML = '';
            LEVELS.forEach((lvl, i) => {
                const d = document.createElement('div');
                d.className = 'level-card';
                if(i >= unlockedLevels) {
                    d.classList.add('locked');
                    d.innerHTML = '<div class="lock-icon">ðŸ”’</div>';
                } else {
                    d.innerHTML = `<div class="lvl-num">${i+1}</div>`;
                    d.onclick = () => fadeTransition(() => loadLevel(i));
                }
                list.appendChild(d);
            });
        }

        function loadLevel(idx) {
            currentLevelIndex = idx;
            loadLevelFromData(LEVELS[idx]);
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('game-ui').style.display = 'flex';
        }

        function loadLevelFromData(data) {
            currentLevelData = data;
            Composite.clear(world);
            particles=[]; tutorialTexts=[]; isDead=false; levelComplete=false;
            
            document.body.style.background = THEMES[data.theme] || THEMES['basic'];
            
            const container = document.getElementById('msg-container');
            container.classList.remove('visible');
            document.getElementById('win-msg').style.display='none';
            document.getElementById('death-msg').style.display='none';
            document.getElementById('level-complete-ui').style.display='none';
            document.getElementById('retry-ui').style.display='none';
            if(document.getElementById('retry-hint')) document.getElementById('retry-hint').style.display='none';
            
            document.getElementById('ui-lvl-num').innerText = currentLevelIndex + 1;
            document.getElementById('level-title').innerText = data.title;
            document.getElementById('level-desc').innerText = data.desc || "";

            addBlock(-200, -5000, 200, 20000, 'wall');

            if(data.blocks) data.blocks.forEach(b => addBlock(b.x, b.y, b.w, b.h, b.type));
            if(data.enemies) data.enemies.forEach(e => addEnemy(e.x, e.y));
            if(data.texts) data.texts.forEach(t => tutorialTexts.push(t));
            
            if(data.goal) addBlock(data.goal.x, data.goal.y, 100, 100, 'goal', { isSensor: true, render: { visible: false }});

            const start = data.playerStart || {x:200, y:600};
            createPlayer(start.x, start.y);
            updateCamera(true);
        }

        function reloadCurrentLevel() { fadeTransition(() => loadLevelFromData(currentLevelData)); }
        
        function loadNextLevel() { 
            if(currentLevelIndex < LEVELS.length - 1) fadeTransition(() => loadLevel(currentLevelIndex + 1));
            else returnToMenu(); 
        }
        
        function returnToMenu() { 
            fadeTransition(() => {
                setupMainMenu();
                document.getElementById('game-ui').style.display = 'none';
                document.getElementById('main-menu').style.display = 'flex';
            });
        }

        function addBlock(x, y, w, h, type, opts={}) {
            let isStatic = true;
            let tex = Textures[type] || Textures['metal'];
            if(type === 'box') { isStatic = false; tex = Textures['box']; }
            if(type === 'wall') tex = null; 
            const renderConfig = tex ? { sprite: { texture: tex, xScale: w/64, yScale: h/64 } } : { visible: true, fillStyle: WORLD_COLORS[type] || '#666' };
            const b = Bodies.rectangle(x+w/2, y+h/2, w, h, { isStatic: isStatic, label: type, render: renderConfig, ...opts });
            Composite.add(world, b);
        }

        function addEnemy(x, y, opts={}) {
            const e = Bodies.rectangle(x, y, 40, 40, { 
                label: 'enemy', 
                friction: 0, 
                frictionAir: 0, 
                render: { sprite: { texture: Textures['enemy'], xScale: 0.8, yScale: 0.8 } },
                ...opts
            });
            const v = opts.velocity || {x:-2, y:0};
            Body.setVelocity(e, v);
            Composite.add(world, e);
        }

        function createPlayer(x, y) {
            const body = Bodies.rectangle(x, y, 40, 60, { label: 'playerBody', render: { sprite: { texture: Textures['player'], xScale: 1.5, yScale: 1.5 } } });
            playerSensor = Bodies.rectangle(x, y+35, 30, 5, { isSensor: true, label: 'sensor', render: { visible: false } });
            player = Body.create({ parts: [body, playerSensor], inertia: Infinity, friction: 0.8, frictionAir: 0.02, label: 'player' });
            Composite.add(world, player);
        }

        function setupCollisionEvents() {
            Events.on(engine, 'collisionStart', evt => {
                if(isDead || levelComplete) return;
                evt.pairs.forEach(p => {
                    const {bodyA, bodyB} = p;
                    const isPlayer = b => b.label==='player' || b.parent.label==='player';
                    let ply = isPlayer(bodyA) ? bodyA : (isPlayer(bodyB) ? bodyB : null);
                    let other = ply===bodyA ? bodyB : bodyA;
                    
                    if(ply && other) {
                        if(other.label === 'booster') {
                            Body.setVelocity(player, { x: player.velocity.x, y: 0 }); 
                            Body.setVelocity(player, { x: player.velocity.x, y: -65 }); 
                            spawnParticles(player.position.x, player.position.y, '#00d2d3', 30);
                            AudioEngine.playJump(); 
                        }
                        else if(other.label === 'enemy') {
                            const main = player.parts.find(x=>x.label==='playerBody');
                            if(player.velocity.y > 0 && main.position.y < other.position.y - 20) {
                                Composite.remove(world, other);
                                Body.setVelocity(player, { x: player.velocity.x, y: -10 });
                                spawnParticles(other.position.x, other.position.y, '#e17055', 20);
                                AudioEngine.playCut(); 
                            } else { die(); }
                        }
                        else if(other.label === 'goal') win();
                    }
                });
            });
        }

        function die() {
            if(isDead) return;
            isDead = true;
            AudioEngine.playDie();
            document.getElementById('msg-container').classList.add('visible');
            document.getElementById('death-msg').style.display='block';
            const hint = document.getElementById('retry-hint'); if(hint) hint.style.display='block';
            document.getElementById('retry-ui').style.display='flex';
            if(player) { Body.setStatic(player, false); player.collisionFilter.group = -1; Body.setVelocity(player, {x:0, y:-10}); }
        }

        function win() {
            if(levelComplete) return;
            levelComplete = true;
            AudioEngine.playWin();
            document.getElementById('msg-container').classList.add('visible');
            document.getElementById('win-msg').style.display='block';
            document.getElementById('level-complete-ui').style.display='flex';
            if(currentLevelIndex >= unlockedLevels - 1 && currentLevelIndex < LEVELS.length - 1) unlockedLevels++;
        }

        function gameLoop() {
            if(!isDead && !levelComplete && player) {
                const others = Composite.allBodies(world).filter(b=>b.id!==player.id && b.label!=='sensor');
                isGrounded = Query.collides(playerSensor, others).length > 0;

                if(keys['KeyD']) Body.setVelocity(player, {x: PLAYER_CONFIG.speed, y: player.velocity.y});
                else if(keys['KeyA']) Body.setVelocity(player, {x: -PLAYER_CONFIG.speed, y: player.velocity.y});
                else if(isGrounded) Body.setVelocity(player, {x: 0, y: player.velocity.y});

                if(keys['Space'] && isGrounded) {
                    Body.setVelocity(player, {x: player.velocity.x, y: -17});
                    isGrounded = false;
                    AudioEngine.playJump();
                }
                
                if (isGrounded && player.velocity.y > 10) AudioEngine.playLand();

                if(player.position.y > 3000) die();

                if(Math.abs(player.velocity.x) > 2 || Math.abs(player.velocity.y) > 2) {
                    trailTimer++;
                    if(trailTimer > 3) {
                        particles.push({ x:player.position.x, y:player.position.y, vx:0, vy:0, life:0.5, decay:0.05, size:30, color:'rgba(0, 210, 211, 0.3)', isTrail:true });
                        trailTimer = 0;
                    }
                }

                // SPAWNER LOGIC
                if(currentLevelData.spawners) {
                    const now = Date.now();
                    currentLevelData.spawners.forEach(s => {
                        if(now - (s.lastSpawn||0) > s.interval) {
                            addEnemy(s.x, s.y, s.enemyOpts || {});
                            s.lastSpawn = now;
                        }
                    });
                }
            }
            updateCamera();
            updateParticles();
        }

        function updateCamera(force) {
            if(!player || !render.bounds) return;
            const z = 2.5; 
            const tx = player.position.x - (window.innerWidth*z)*0.4;
            const ty = player.position.y - (window.innerHeight*z)*0.5;
            const sm = force ? 1 : 0.1;
            if(!render.bounds.min) return;
            render.bounds.min.x += (tx - render.bounds.min.x) * sm;
            render.bounds.min.y += (ty - render.bounds.min.y) * sm;
            render.bounds.max.x = render.bounds.min.x + window.innerWidth*z;
            render.bounds.max.y = render.bounds.min.y + window.innerHeight*z;
        }

        function screenToWorld(sx, sy) {
            const rect = render.canvas.getBoundingClientRect();
            const bw = render.bounds.max.x - render.bounds.min.x;
            const bh = render.bounds.max.y - render.bounds.min.y;
            return { x: render.bounds.min.x + ((sx-rect.left)/rect.width)*bw, y: render.bounds.min.y + ((sy-rect.top)/rect.height)*bh };
        }

        const keys = {};
        function setupInputs() {
            window.onkeydown = e => { keys[e.code]=true; if(e.code==='KeyR') reloadCurrentLevel(); };
            window.onkeyup = e => keys[e.code]=false;
            const c = document.getElementById('world');
            c.onmousedown = e => {
                if(isDead || levelComplete || !player) return;
                isDragging=true; dragStart = screenToWorld(e.clientX, e.clientY); dragCurrent = dragStart;
            };
            window.onmousemove = e => { if(isDragging) { dragCurrent = screenToWorld(e.clientX, e.clientY); validateCut(); }};
            window.onmouseup = () => { if(isDragging) { isDragging=false; if(isCutValid) performCut(); document.getElementById('cut-status').style.display='none'; }};
        }

        function validateCut() {
            const p1 = Math.min(dragStart.x, dragCurrent.x);
            const p2 = Math.max(dragStart.x, dragCurrent.x);
            isCutValid = !Composite.allBodies(world).some(b => b.label==='metal' && b.bounds.max.x > p1 && b.bounds.min.x < p2);
            const status = document.getElementById('cut-status');
            if(!isCutValid) { status.style.display = 'block'; document.body.style.cursor = 'not-allowed'; }
            else { status.style.display = 'none'; document.body.style.cursor = 'crosshair'; }
        }

        function performCut() {
            document.body.style.cursor = 'default';
            const p1 = Math.min(dragStart.x, dragCurrent.x);
            const p2 = Math.max(dragStart.x, dragCurrent.x);
            const size = p2 - p1;
            if(size < 10) return;
            
            AudioEngine.playCut();
            
            const f = document.getElementById('flash-overlay'); f.style.opacity=0.5; setTimeout(()=>f.style.opacity=0, 100);
            const toRemove = [];
            Composite.allBodies(world).forEach(b => {
                if(b.label.includes('player') || b.label==='sensor' || b.label==='wall') return;
                const center = b.position.x;
                if(center >= p1 && center <= p2) { toRemove.push(b); spawnParticles(b.position.x, b.position.y, '#fff', 10); }
                else if(center > p2) { Body.translate(b, {x: -size, y: 0}); if(!b.isStatic) Body.setVelocity(b, {x:0, y:0}); }
            });
            Composite.remove(world, toRemove);
            if(player.position.x > p2) Body.translate(player, {x: -size, y: 0});
            else if(player.position.x > p1 && player.position.x < p2) Body.translate(player, {x: -size, y: 0});
            for(let y=render.bounds.min.y; y<render.bounds.max.y; y+=100) spawnParticles(p1, y, '#55efc4', 2);
        }

        function renderCustom(ctx) {
            const rect = render.canvas.getBoundingClientRect();
            const bw = render.bounds.max.x - render.bounds.min.x;
            const bh = render.bounds.max.y - render.bounds.min.y;
            const rctx = render.context;

            // TEXTS
            rctx.save(); 
            rctx.setTransform(1,0,0,1,0,0); 
            rctx.textAlign='center'; 
            rctx.font='12px "Press Start 2P"'; 
            
            tutorialTexts.forEach(t => {
                const sx = ((t.x - render.bounds.min.x)/bw)*rect.width;
                const sy = ((t.y - render.bounds.min.y)/bh)*rect.height;
                if(sx>-100 && sx<rect.width+100) {
                    const w = rctx.measureText(t.content).width + 20;
                    rctx.fillStyle = 'rgba(0,0,0,0.6)';
                    rctx.fillRect(sx - w/2, sy - 15, w, 25);
                    rctx.fillStyle='white'; 
                    rctx.fillText(t.content, sx, sy+5);
                }
            });
            rctx.restore();

            // PORTAL ANIMATION
            const bodies = Composite.allBodies(world);
            bodies.forEach(b => {
                if (b.label === 'goal') {
                    const sx = ((b.position.x - render.bounds.min.x) / bw) * rect.width;
                    const sy = ((b.position.y - render.bounds.min.y) / bh) * rect.height;
                    const size = (100 / bw) * rect.width; 
                    const time = engine.timing.timestamp;

                    rctx.save();
                    rctx.setTransform(1,0,0,1,0,0);
                    rctx.translate(sx, sy);
                    rctx.rotate(time * 0.003);
                    rctx.shadowBlur = 20; rctx.shadowColor = '#55efc4';
                    rctx.strokeStyle = '#55efc4'; rctx.lineWidth = 4;
                    rctx.strokeRect(-size/2, -size/2, size, size);
                    rctx.rotate(time * -0.006);
                    rctx.scale(0.6, 0.6);
                    rctx.strokeRect(-size/2, -size/2, size, size);
                    rctx.fillStyle = '#fff'; rctx.fillRect(-10, -10, 20, 20);
                    rctx.restore();
                }
            });

            if(isDragging) {
                const sX = ((dragStart.x - render.bounds.min.x)/bw)*rect.width;
                const cX = ((dragCurrent.x - render.bounds.min.x)/bw)*rect.width;
                const x = Math.min(sX, cX), w = Math.abs(sX - cX);
                
                rctx.save(); rctx.setTransform(1,0,0,1,0,0);
                if(isCutValid) {
                    rctx.fillStyle = 'rgba(85, 239, 196, 0.2)';
                    rctx.strokeStyle = '#55efc4';
                } else {
                    rctx.fillStyle = 'rgba(255, 118, 117, 0.3)'; 
                    rctx.strokeStyle = '#ff7675';
                }
                rctx.lineWidth = 4;
                rctx.fillRect(x, 0, w, rect.height);
                rctx.strokeRect(x, 0, w, rect.height);
                rctx.restore();
            }

            rctx.save(); rctx.setTransform(1,0,0,1,0,0);
            particles.forEach(p => {
                rctx.globalAlpha = p.life; 
                rctx.fillStyle = p.color;
                const sx = ((p.x - render.bounds.min.x)/bw)*rect.width;
                const sy = ((p.y - render.bounds.min.y)/bh)*rect.height;
                if(p.isTrail) rctx.fillRect(sx - 15, sy - 25, 30, 50); 
                else rctx.fillRect(sx, sy, p.size, p.size);
            });
            rctx.restore();
        }

        function spawnParticles(x, y, c, n) { for(let i=0; i<n; i++) particles.push({ x, y, vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10, life:1, decay:0.05, size:4+Math.random()*4, color:c }); }
        function updateParticles() { for(let i=particles.length-1; i>=0; i--) { particles[i].x += particles[i].vx; particles[i].y += particles[i].vy; particles[i].life -= particles[i].decay; if(particles[i].life<=0) particles.splice(i,1); } }

        window.onload = init;
    </script>
</body>
</html>
